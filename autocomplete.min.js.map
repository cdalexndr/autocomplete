{"version":3,"file":"autocomplete.min.js","sources":["autocomplete.ts"],"sourcesContent":["/*\r\n * https://github.com/kraaden/autocomplete\r\n * Copyright (c) 2016 Denys Krasnoshchok\r\n * MIT License\r\n */\r\n\r\nexport const enum EventTrigger {\r\n    Keyboard = 0,\r\n    Focus = 1\r\n}\r\n\r\nexport interface AutocompleteItem {\r\n    label?: string;\r\n    group?: string;\r\n}\r\n\r\nexport interface AutocompleteSettings<T extends AutocompleteItem> {\r\n    input: HTMLInputElement;\r\n    render?: (item: T, currentValue: string) => HTMLDivElement | undefined;\r\n    renderGroup?: (name: string, currentValue: string) => HTMLDivElement | undefined;\r\n    className?: string;\r\n    minLength?: number;\r\n    emptyMsg?: string;\r\n    onSelect: (item: T, input: HTMLInputElement) => void;\r\n    /**\r\n     * Show autocomplete on focus event. Focus event will ignore the `minLength` property and will always call `fetch`.\r\n     */\r\n    showOnFocus?: boolean;\r\n    fetch: (text: string, update: (items: T[] | false) => void, trigger: EventTrigger) => void;\r\n    debounceWaitMs?: number;\r\n    /**\r\n     * Callback for additional autocomplete customization\r\n     * @param {HTMLInputElement} input - input box associated with autocomplete\r\n     * @param {ClientRect | DOMRect} inputRect - size of the input box and its position relative to the viewport\r\n     * @param {HTMLDivElement} container - container with suggestions\r\n     * @param {number} maxHeight - max height that can be used by autocomplete\r\n     */\r\n    customize?: (input: HTMLInputElement, inputRect: ClientRect | DOMRect, container: HTMLDivElement, maxHeight: number) => void;\r\n    /**\r\n     * Prevents automatic form submit when ENTER is pressed\r\n     */\r\n    preventSubmit?: boolean;\r\n    /**\r\n     * Prevents automatic selection of first entry when ENTER is pressed\r\n     */\r\n    disableAutoSelect?: boolean;\r\n}\r\n\r\nexport interface AutocompleteResult {\r\n    destroy: () => void;\r\n}\r\n\r\nconst enum Keys {\r\n    Enter = 13,\r\n    Esc = 27,\r\n    Up = 38,\r\n    Down = 40,\r\n    Left = 37,\r\n    Right = 39,\r\n    Shift = 16,\r\n    Ctrl = 17,\r\n    Alt = 18,\r\n    CapsLock = 20,\r\n    WindowsKey = 91,\r\n    Tab = 9\r\n}\r\n\r\nexport default function autocomplete<T extends AutocompleteItem>(settings: AutocompleteSettings<T>): AutocompleteResult {\r\n\r\n    // just an alias to minimize JS file size\r\n    const doc = document;\r\n\r\n    const container: HTMLDivElement = doc.createElement(\"div\");\r\n    const containerStyle = container.style;\r\n    const userAgent = navigator.userAgent;\r\n    const mobileFirefox = userAgent.indexOf(\"Firefox\") !== -1 && userAgent.indexOf(\"Mobile\") !== -1;\r\n    const debounceWaitMs = settings.debounceWaitMs || 0;\r\n    const preventSubmit = settings.preventSubmit || false;\r\n\r\n    // 'keyup' event will not be fired on Mobile Firefox, so we have to use 'input' event instead\r\n    const keyUpEventName = mobileFirefox ? \"input\" : \"keyup\";\r\n\r\n    let items: T[] = [];\r\n    let inputValue = \"\";\r\n    let minLen = 2;\r\n    const showOnFocus = settings.showOnFocus;\r\n    let selected: T | undefined;\r\n    let keypressCounter = 0;\r\n    let debounceTimer: number | undefined;\r\n\r\n    if (settings.minLength !== undefined) {\r\n        minLen = settings.minLength;\r\n    }\r\n\r\n    if (!settings.input) {\r\n        throw new Error(\"input undefined\");\r\n    }\r\n\r\n    const input: HTMLInputElement = settings.input;\r\n\r\n    container.className = \"autocomplete \" + (settings.className || \"\");\r\n    containerStyle.position = \"fixed\";\r\n\r\n    /**\r\n     * Detach the container from DOM\r\n     */\r\n    function detach(): void {\r\n        const parent = container.parentNode;\r\n        if (parent) {\r\n            parent.removeChild(container);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Detect if the script is running on IOS\r\n     */\r\n    function isIOS() {\r\n        return /iPad|iPhone|iPod/.test(window.navigator.userAgent) && !(window as any).MSStream;\r\n    }\r\n\r\n    /**\r\n     * Clear debouncing timer if assigned\r\n     */\r\n    function clearDebounceTimer(): void {\r\n        if (debounceTimer) {\r\n            window.clearTimeout(debounceTimer);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Attach the container to DOM\r\n     */\r\n    function attach(): void {\r\n        if (!container.parentNode) {\r\n            doc.body.appendChild(container);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Check if container for autocomplete is displayed\r\n     */\r\n    function containerDisplayed(): boolean {\r\n        return !!container.parentNode;\r\n    }\r\n\r\n    /**\r\n     * Clear autocomplete state and hide container\r\n     */\r\n    function clear(): void {\r\n        keypressCounter++;\r\n        items = [];\r\n        inputValue = \"\";\r\n        selected = undefined;\r\n        detach();\r\n    }\r\n\r\n    /**\r\n     * Update autocomplete position\r\n     */\r\n    function updatePosition(): void {\r\n        if (!containerDisplayed()) {\r\n            return;\r\n        }\r\n\r\n        containerStyle.height = \"auto\";\r\n        containerStyle.width = input.offsetWidth + \"px\";\r\n\r\n        const inputRect = input.getBoundingClientRect();\r\n        let top = isIOS()\r\n            ? inputRect.top + window.pageYOffset // a fix for buggy getBoundingClientRect on IOS\r\n            : inputRect.top;\r\n\r\n        top = top + input.offsetHeight;\r\n\r\n        let maxHeight = window.innerHeight - (inputRect.top + input.offsetHeight);\r\n\r\n        if (maxHeight < 0) {\r\n            maxHeight = 0;\r\n        }\r\n\r\n        containerStyle.top = top + \"px\";\r\n        containerStyle.bottom = \"\";\r\n        containerStyle.left = inputRect.left + \"px\";\r\n        containerStyle.maxHeight = maxHeight + \"px\";\r\n\r\n        if (settings.customize) {\r\n            settings.customize(input, inputRect, container, maxHeight);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Redraw the autocomplete div element with suggestions\r\n     */\r\n    function update(): void {\r\n\r\n        // delete all children from autocomplete DOM container\r\n        while (container.firstChild) {\r\n            container.removeChild(container.firstChild);\r\n        }\r\n\r\n        // function for rendering autocomplete suggestions\r\n        let render = function(item: T, currentValue: string): HTMLDivElement | undefined {\r\n            const itemElement = doc.createElement(\"div\");\r\n            itemElement.textContent = item.label || \"\";\r\n            return itemElement;\r\n        };\r\n        if (settings.render) {\r\n            render = settings.render;\r\n        }\r\n\r\n        // function to render autocomplete groups\r\n        let renderGroup = function(groupName: string, currentValue: string): HTMLDivElement | undefined {\r\n            const groupDiv = doc.createElement(\"div\");\r\n            groupDiv.textContent = groupName;\r\n            return groupDiv;\r\n        };\r\n        if (settings.renderGroup) {\r\n            renderGroup = settings.renderGroup;\r\n        }\r\n\r\n        const fragment = doc.createDocumentFragment();\r\n        let prevGroup = \"#9?$\";\r\n\r\n        items.forEach(function(item: T): void {\r\n            if (item.group && item.group !== prevGroup) {\r\n                prevGroup = item.group;\r\n                const groupDiv = renderGroup(item.group, inputValue);\r\n                if (groupDiv) {\r\n                    groupDiv.className += \" group\";\r\n                    fragment.appendChild(groupDiv);\r\n                }\r\n            }\r\n            const div = render(item, inputValue);\r\n            if (div) {\r\n                div.addEventListener(\"click\", function(ev: MouseEvent): void {\r\n                    settings.onSelect(item, input);\r\n                    clear();\r\n                    ev.preventDefault();\r\n                    ev.stopPropagation();\r\n                });\r\n                if (item === selected) {\r\n                    div.className += \" selected\";\r\n                }\r\n                fragment.appendChild(div);\r\n            }\r\n        });\r\n        container.appendChild(fragment);\r\n        if (items.length < 1) {\r\n            if (settings.emptyMsg) {\r\n                const empty = doc.createElement(\"div\");\r\n                empty.className = \"empty\";\r\n                empty.textContent = settings.emptyMsg;\r\n                container.appendChild(empty);\r\n            } else {\r\n                clear();\r\n                return;\r\n            }\r\n        }\r\n\r\n        attach();\r\n        updatePosition();\r\n\r\n        updateScroll();\r\n    }\r\n\r\n    function updateIfDisplayed(): void {\r\n        if (containerDisplayed()) {\r\n            update();\r\n        }\r\n    }\r\n\r\n    function resizeEventHandler(): void {\r\n        updateIfDisplayed();\r\n    }\r\n\r\n    function scrollEventHandler(e: Event): void {\r\n        if (e.target !== container) {\r\n            updateIfDisplayed();\r\n        } else {\r\n            e.preventDefault();\r\n        }\r\n    }\r\n\r\n    function keyupEventHandler(ev: KeyboardEvent): void {\r\n        const keyCode = ev.which || ev.keyCode || 0;\r\n\r\n        const ignore = [Keys.Up, Keys.Enter, Keys.Esc, Keys.Right, Keys.Left, Keys.Shift, Keys.Ctrl, Keys.Alt, Keys.CapsLock, Keys.WindowsKey, Keys.Tab];\r\n        for (const key of ignore) {\r\n            if (keyCode === key) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        // the down key is used to open autocomplete\r\n        if (keyCode === Keys.Down && containerDisplayed()) {\r\n            return;\r\n        }\r\n\r\n        startFetch(EventTrigger.Keyboard);\r\n    }\r\n\r\n    /**\r\n     * Automatically move scroll bar if selected item is not visible\r\n     */\r\n    function updateScroll(): void {\r\n        const elements = container.getElementsByClassName(\"selected\");\r\n        if (elements.length > 0) {\r\n            let element = elements[0] as HTMLDivElement;\r\n\r\n            // make group visible\r\n            const previous = element.previousElementSibling as HTMLDivElement;\r\n            if (previous && previous.className.indexOf(\"group\") !== -1 && !previous.previousElementSibling) {\r\n                element = previous;\r\n            }\r\n\r\n            if (element.offsetTop < container.scrollTop) {\r\n                container.scrollTop = element.offsetTop;\r\n            } else {\r\n                const selectBottom = element.offsetTop + element.offsetHeight;\r\n                const containerBottom = container.scrollTop + container.offsetHeight;\r\n                if (selectBottom > containerBottom) {\r\n                    container.scrollTop += selectBottom - containerBottom;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Select the previous item in suggestions\r\n     */\r\n    function selectPrev(): void {\r\n        if (items.length < 1) {\r\n            selected = undefined;\r\n        } else if (!selected) {\r\n            selected = items[items.length - 1];\r\n        } else if (selected === items[0]) {\r\n            selected = settings.disableAutoSelect ? undefined : items[items.length - 1];\r\n        } else {\r\n            for (let i = items.length - 1; i > 0; i--) {\r\n                if (selected === items[i] || i === 1) {\r\n                    selected = items[i - 1];\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * Select the next item in suggestions\r\n     */\r\n    function selectNext(): void {\r\n        if (items.length < 1) {\r\n            selected = undefined;\r\n        } else if (!selected) {\r\n            selected = items[0];\r\n        } else if (selected === items[items.length - 1]) {\r\n            selected = settings.disableAutoSelect ? undefined : items[0];\r\n        } else {\r\n            for (let i = 0; i < (items.length - 1); i++) {\r\n                if (selected === items[i]) {\r\n                    selected = items[i + 1];\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function keydownEventHandler(ev: KeyboardEvent): void {\r\n        const keyCode = ev.which || ev.keyCode || 0;\r\n\r\n        if (keyCode === Keys.Up || keyCode === Keys.Down || keyCode === Keys.Esc) {\r\n            const containerIsDisplayed = containerDisplayed();\r\n\r\n            if (keyCode === Keys.Esc) {\r\n                clear();\r\n            } else {\r\n                if (!containerDisplayed || items.length < 1) {\r\n                    return;\r\n                }\r\n                keyCode === Keys.Up\r\n                    ? selectPrev()\r\n                    : selectNext();\r\n                update();\r\n            }\r\n\r\n            ev.preventDefault();\r\n            if (containerIsDisplayed) {\r\n                ev.stopPropagation();\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        if (keyCode === Keys.Enter) {\r\n            if (selected) {\r\n                settings.onSelect(selected, input);\r\n                clear();\r\n            }\r\n    \r\n            if (preventSubmit) {\r\n                ev.preventDefault();\r\n            }\r\n        }\r\n    }\r\n\r\n    function focusEventHandler(): void {\r\n        if (showOnFocus) {\r\n            startFetch(EventTrigger.Focus);\r\n        }\r\n    }\r\n\r\n    function startFetch(trigger: EventTrigger) {\r\n        // if multiple keys were pressed, before we get update from server,\r\n        // this may cause redrawing our autocomplete multiple times after the last key press.\r\n        // to avoid this, the number of times keyboard was pressed will be\r\n        // saved and checked before redraw our autocomplete box.\r\n        const savedKeypressCounter = ++keypressCounter;\r\n\r\n        const val = input.value;\r\n        if (val.length >= minLen || trigger === EventTrigger.Focus) {\r\n            clearDebounceTimer();\r\n            debounceTimer = window.setTimeout(function(): void {\r\n                settings.fetch(val, function(elements: T[] | false): void {\r\n                    if (keypressCounter === savedKeypressCounter && elements) {\r\n                        items = elements;\r\n                        inputValue = val;\r\n                        selected = (items.length < 1 || settings.disableAutoSelect) ? undefined : items[0];\r\n                        update();\r\n                    }\r\n                }, EventTrigger.Keyboard);\r\n            }, trigger === EventTrigger.Keyboard ? debounceWaitMs : 0);\r\n        } else {\r\n            clear();\r\n        }\r\n    }\r\n\r\n    function blurEventHandler(): void {\r\n        // we need to delay clear, because when we click on an item, blur will be called before click and remove items from DOM\r\n        setTimeout(() => {\r\n            if (doc.activeElement !== input) {\r\n                clear();\r\n            }\r\n        }, 200);\r\n    }\r\n\r\n    /**\r\n     * Fixes #26: on long clicks focus will be lost and onSelect method will not be called\r\n     */\r\n    container.addEventListener(\"mousedown\", function(evt: Event) {\r\n        evt.stopPropagation();\r\n        evt.preventDefault();\r\n    });\r\n\r\n    /**\r\n     * This function will remove DOM elements and clear event handlers\r\n     */\r\n    function destroy(): void {\r\n        input.removeEventListener(\"focus\", focusEventHandler);\r\n        input.removeEventListener(\"keydown\", keydownEventHandler);\r\n        input.removeEventListener(keyUpEventName, keyupEventHandler as EventListenerOrEventListenerObject);\r\n        input.removeEventListener(\"blur\", blurEventHandler);\r\n        window.removeEventListener(\"resize\", resizeEventHandler);\r\n        doc.removeEventListener(\"scroll\", scrollEventHandler, true);\r\n        clearDebounceTimer();\r\n        clear();\r\n\r\n        // prevent the update call if there are pending AJAX requests\r\n        keypressCounter++;\r\n    }\r\n\r\n    // setup event handlers\r\n    input.addEventListener(\"keydown\", keydownEventHandler);\r\n    input.addEventListener(keyUpEventName, keyupEventHandler as EventListenerOrEventListenerObject);\r\n    input.addEventListener(\"blur\", blurEventHandler);\r\n    input.addEventListener(\"focus\", focusEventHandler);\r\n    window.addEventListener(\"resize\", resizeEventHandler);\r\n    doc.addEventListener(\"scroll\", scrollEventHandler, true);\r\n\r\n    return {\r\n        destroy\r\n    };\r\n}\r\n"],"names":["settings","selected","debounceTimer","doc","document","container","createElement","containerStyle","style","userAgent","navigator","mobileFirefox","indexOf","debounceWaitMs","preventSubmit","keyUpEventName","items","inputValue","minLen","showOnFocus","keypressCounter","undefined","minLength","input","Error","clearDebounceTimer","window","clearTimeout","containerDisplayed","parentNode","clear","parent","removeChild","updatePosition","height","width","offsetWidth","inputRect","getBoundingClientRect","top","test","MSStream","pageYOffset","offsetHeight","maxHeight","innerHeight","bottom","left","customize","update","firstChild","render","item","currentValue","itemElement","textContent","label","renderGroup","groupName","groupDiv","fragment","createDocumentFragment","prevGroup","forEach","group","className","appendChild","div","addEventListener","ev","onSelect","preventDefault","stopPropagation","length","emptyMsg","empty","body","elements","getElementsByClassName","element","previous","previousElementSibling","offsetTop","scrollTop","selectBottom","containerBottom","updateScroll","updateIfDisplayed","resizeEventHandler","scrollEventHandler","e","target","keyupEventHandler","keyCode","which","ignore_1","_i","startFetch","keydownEventHandler","containerIsDisplayed","disableAutoSelect","i","selectPrev","selectNext","focusEventHandler","trigger","savedKeypressCounter","val","value","setTimeout","fetch","blurEventHandler","activeElement","position","evt","destroy","removeEventListener"],"mappings":"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"}